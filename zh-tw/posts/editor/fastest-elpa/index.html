<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>最快的 ELPA | Jen-Chieh's Website</title>
<meta name=keywords content="Editor,Emacs,ELPA"><meta name=description content='所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏
輯. ELPA 最快服務你? 或許, 但我不知道!
在這裡我們定義"最快的 ELPA"為建構插件的速度. 也就是多久以後我們的插件會
被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說
&ldquo;怎麼可能?&rdquo; 還有 &ldquo;怎麼做到的?&rdquo;, 讓我一一解釋!

一般的 ELPA, 像是 MELPA, 他們會從 recipes 資料夾裡取得需要建構的插件目標.
這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升
硬體硬件, 來促使減少建構時間.
這裡 JCS-ELPA 使用了不同的策略. 這個 ELPA 使用了一個插件 github-elpa
來使其建構我們的插件然後上傳到 GitHub Pages. 所以到底為什麼會是最快?
主要有兩個因素:

微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上
我們使用 GitHub Actions 建構插件, 定且使用了多個 jobs (如果你不熟悉
GHA, 就想說有很多台電腦在幫你做事即可)

JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:
新的建構總時長 = 原本建構總時長 / 工作者
如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善).
舉例, 如果原本建構總時長是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.'><meta name=author content="Jen-Chieh Shen"><link rel=canonical href=https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/><link crossorigin=anonymous href=/assets/css/stylesheet.10865c4b1b2c43287bba4052ebb8a4e620e0b2e0a66e319556682d1d0d6e0496.css integrity="sha256-EIZcSxssQyh7ukBS67ik5iDgsuCmbjGVVmgtHQ1uBJY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.jcs-profile.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.jcs-profile.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.jcs-profile.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.jcs-profile.com/apple-touch-icon.png><link rel=mask-icon href=https://www.jcs-profile.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/><link rel=alternate hreflang=en href=https://www.jcs-profile.com/posts/editor/fastest-elpa/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MLWCB75D6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MLWCB75D6")}</script><meta property="og:url" content="https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/"><meta property="og:site_name" content="Jen-Chieh's Website"><meta property="og:title" content="最快的 ELPA"><meta property="og:description" content='所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏 輯. ELPA 最快服務你? 或許, 但我不知道!
在這裡我們定義"最快的 ELPA"為建構插件的速度. 也就是多久以後我們的插件會 被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說 “怎麼可能?” 還有 “怎麼做到的?”, 讓我一一解釋!
一般的 ELPA, 像是 MELPA, 他們會從 recipes 資料夾裡取得需要建構的插件目標. 這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升 硬體硬件, 來促使減少建構時間.
這裡 JCS-ELPA 使用了不同的策略. 這個 ELPA 使用了一個插件 github-elpa 來使其建構我們的插件然後上傳到 GitHub Pages. 所以到底為什麼會是最快? 主要有兩個因素:
微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上 我們使用 GitHub Actions 建構插件, 定且使用了多個 jobs (如果你不熟悉 GHA, 就想說有很多台電腦在幫你做事即可) JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:
新的建構總時長 = 原本建構總時長 / 工作者 如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善). 舉例, 如果原本建構總時長是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.'><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-10T00:00:00+00:00"><meta property="article:tag" content="Editor"><meta property="article:tag" content="Emacs"><meta property="article:tag" content="ELPA"><meta property="og:image" content="https://www.jcs-profile.com/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.jcs-profile.com/cover.png"><meta name=twitter:title content="最快的 ELPA"><meta name=twitter:description content='所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏
輯. ELPA 最快服務你? 或許, 但我不知道!
在這裡我們定義"最快的 ELPA"為建構插件的速度. 也就是多久以後我們的插件會
被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說
&ldquo;怎麼可能?&rdquo; 還有 &ldquo;怎麼做到的?&rdquo;, 讓我一一解釋!

一般的 ELPA, 像是 MELPA, 他們會從 recipes 資料夾裡取得需要建構的插件目標.
這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升
硬體硬件, 來促使減少建構時間.
這裡 JCS-ELPA 使用了不同的策略. 這個 ELPA 使用了一個插件 github-elpa
來使其建構我們的插件然後上傳到 GitHub Pages. 所以到底為什麼會是最快?
主要有兩個因素:

微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上
我們使用 GitHub Actions 建構插件, 定且使用了多個 jobs (如果你不熟悉
GHA, 就想說有很多台電腦在幫你做事即可)

JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:
新的建構總時長 = 原本建構總時長 / 工作者
如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善).
舉例, 如果原本建構總時長是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.jcs-profile.com/zh-tw/posts/"},{"@type":"ListItem","position":2,"name":"最快的 ELPA","item":"https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"最快的 ELPA","name":"最快的 ELPA","description":"所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏 輯. ELPA 最快服務你? 或許, 但我不知道!\n在這裡我們定義\u0026quot;最快的 ELPA\u0026quot;為建構插件的速度. 也就是多久以後我們的插件會 被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說 \u0026ldquo;怎麼可能?\u0026rdquo; 還有 \u0026ldquo;怎麼做到的?\u0026rdquo;, 讓我一一解釋!\n一般的 ELPA, 像是 MELPA, 他們會從 recipes 資料夾裡取得需要建構的插件目標. 這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升 硬體硬件, 來促使減少建構時間.\n這裡 JCS-ELPA 使用了不同的策略. 這個 ELPA 使用了一個插件 github-elpa 來使其建構我們的插件然後上傳到 GitHub Pages. 所以到底為什麼會是最快? 主要有兩個因素:\n微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上 我們使用 GitHub Actions 建構插件, 定且使用了多個 jobs (如果你不熟悉 GHA, 就想說有很多台電腦在幫你做事即可) JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:\n新的建構總時長 = 原本建構總時長 / 工作者 如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善). 舉例, 如果原本建構總時長是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.\n","keywords":["Editor","Emacs","ELPA"],"articleBody":"所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏 輯. ELPA 最快服務你? 或許, 但我不知道!\n在這裡我們定義\"最快的 ELPA\"為建構插件的速度. 也就是多久以後我們的插件會 被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說 “怎麼可能?” 還有 “怎麼做到的?”, 讓我一一解釋!\n一般的 ELPA, 像是 MELPA, 他們會從 recipes 資料夾裡取得需要建構的插件目標. 這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升 硬體硬件, 來促使減少建構時間.\n這裡 JCS-ELPA 使用了不同的策略. 這個 ELPA 使用了一個插件 github-elpa 來使其建構我們的插件然後上傳到 GitHub Pages. 所以到底為什麼會是最快? 主要有兩個因素:\n微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上 我們使用 GitHub Actions 建構插件, 定且使用了多個 jobs (如果你不熟悉 GHA, 就想說有很多台電腦在幫你做事即可) JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:\n新的建構總時長 = 原本建構總時長 / 工作者 如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善). 舉例, 如果原本建構總時長是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.\n2 min = 10 min / 5 jobs 當然這是理論上的計算, 實際上還要扣掉排程時間, 開啟和關閉工作者的時間, 等等 的相關因素. 不過原理上, 當你要建構的插件越多效果就越拔群!\n👷 如果實踐的? 💡 因為 JCS-ELPA 沒有足夠多的插件來實行這個理論. 所以我們這裡只解釋這個 是怎麼運作的!\n現今, JCS-ELPA 擁有 136 的插件. 我把他分為更小的區塊. 比如一個工作者負責 50 個插件! 公式如下:\njobs = (total recipes / recipes per section) + 1 因此:\n3 = (136 / 50) + 1 現在你有 3 個工作者幫你分擔建構任務! 原本的時長是大約 3 ~ 4 分鐘, 現在 直接變成 1 分鐘! 這是很大的進步! 😄\n其中一個最棒的是, 你可以直接看 GHA 的日誌來觀察其中的過程!\n","wordCount":"156","inLanguage":"zh-tw","image":"https://www.jcs-profile.com/cover.png","datePublished":"2023-04-10T00:00:00Z","dateModified":"2023-04-10T00:00:00Z","author":[{"@type":"Person","name":"Jen-Chieh Shen"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/"},"publisher":{"@type":"Organization","name":"Jen-Chieh's Website","logo":{"@type":"ImageObject","url":"https://www.jcs-profile.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.jcs-profile.com/zh-tw/ accesskey=h title="Jen-Chieh's Website (Alt + H)">Jen-Chieh's Website</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.jcs-profile.com/ title=En aria-label=En>En</a></li></ul></div></div><ul id=menu><li><a href=https://www.jcs-profile.com/zh-tw/blog/ title=部落格><span>部落格</span></a></li><li><a href=https://www.jcs-profile.com/zh-tw/projects/ title=專案><span>專案</span></a></li><li><a href=https://www.artstation.com/jcs090218 title=藝術><span>藝術</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.jcs-profile.com/storage/Resume.pdf title=履歷><span>履歷</span></a></li><li><a href=https://www.jcs-profile.com/zh-tw/contact/ title=聯絡><span>聯絡</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.jcs-profile.com/zh-tw/>首頁</a>&nbsp;»&nbsp;<a href=https://www.jcs-profile.com/zh-tw/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">最快的 ELPA</h1><div class=post-meta><span title='2023-04-10 00:00:00 +0000 UTC'>April 10, 2023</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;156 字&nbsp;·&nbsp;Jen-Chieh Shen&nbsp;|&nbsp;語言:<ul class=i18n_list><li><a href=https://www.jcs-profile.com/posts/editor/fastest-elpa/>En</a></li></ul></div></header><figure class=entry-cover><img loading=eager src=https://www.jcs-profile.com/cover.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#-%e5%a6%82%e6%9e%9c%e5%af%a6%e8%b8%90%e7%9a%84 aria-label="👷 如果實踐的?">👷 如果實踐的?</a></li></ul></div></details></div><div class=post-content><p>所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏
輯. ELPA 最快服務你? 或許, 但我不知道!</p><p>在這裡我們定義"最快的 ELPA"為建構插件的速度. 也就是多久以後我們的插件會
被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說
&ldquo;怎麼可能?&rdquo; 還有 &ldquo;怎麼做到的?&rdquo;, 讓我一一解釋!</p><p>一般的 ELPA, 像是 MELPA, 他們會從 <code>recipes</code> 資料夾裡取得需要建構的插件目標.
這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升
硬體硬件, 來促使減少建構時間.</p><p>這裡 <a href=https://jcs-emacs.github.io/jcs-elpa/>JCS-ELPA</a> 使用了不同的策略. 這個 ELPA 使用了一個插件 <a href=https://github.com/10sr/github-elpa>github-elpa</a>
來使其建構我們的插件然後上傳到 <a href=https://pages.github.com/>GitHub Pages</a>. 所以到底為什麼會是最快?
主要有兩個因素:</p><ol><li>微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上</li><li>我們使用 <a href=https://github.com/features/actions>GitHub Actions</a> 建構插件, 定且使用了多個 jobs (如果你不熟悉
GHA, 就想說有很多台電腦在幫你做事即可)</li></ol><p>JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:</p><pre tabindex=0><code>新的建構總時長 = 原本建構總時長 / 工作者
</code></pre><p>如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善).
舉例, 如果<code>原本建構總時長</code>是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.</p><pre tabindex=0><code>2 min = 10 min / 5 jobs
</code></pre><p>當然這是理論上的計算, 實際上還要扣掉排程時間, 開啟和關閉工作者的時間, 等等
的相關因素. 不過原理上, 當你要建構的插件越多效果就越拔群!</p><h2 id=-如果實踐的>👷 如果實踐的?<a hidden class=anchor aria-hidden=true href=#-如果實踐的>#</a></h2><blockquote><p>💡 因為 JCS-ELPA 沒有足夠多的插件來實行這個理論. 所以我們這裡只解釋這個
是怎麼運作的!</p></blockquote><p>現今, JCS-ELPA 擁有 136 的插件. 我把他分為更小的區塊. 比如一個工作者負責
50 個插件! 公式如下:</p><pre tabindex=0><code>jobs = (total recipes / recipes per section) + 1
</code></pre><p>因此:</p><pre tabindex=0><code>3 = (136 / 50) + 1
</code></pre><p>現在你有 3 個工作者幫你分擔建構任務! 原本的時長是大約 3 ~ 4 分鐘, 現在
直接變成 1 分鐘! 這是很大的進步! 😄</p><p><img loading=lazy src=/posts/editor/fastest-elpa/jobs.png></p><p>其中一個最棒的是, 你可以直接看 GHA 的日誌來觀察其中的過程!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.jcs-profile.com/zh-tw/tags/editor/>Editor</a></li><li><a href=https://www.jcs-profile.com/zh-tw/tags/emacs/>Emacs</a></li><li><a href=https://www.jcs-profile.com/zh-tw/tags/elpa/>ELPA</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.jcs-profile.com/zh-tw/>Jen-Chieh's Website</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>