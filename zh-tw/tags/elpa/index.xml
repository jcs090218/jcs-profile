<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ELPA on Jen-Chieh&#39;s Website</title>
    <link>https://www.jcs-profile.com/zh-tw/tags/elpa/</link>
    <description>Recent content in ELPA on Jen-Chieh&#39;s Website</description>
    <generator>Hugo -- 0.147.2</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 10 Apr 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.jcs-profile.com/zh-tw/tags/elpa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最快的 ELPA</title>
      <link>https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/</link>
      <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://www.jcs-profile.com/zh-tw/posts/editor/fastest-elpa/</guid>
      <description>&lt;p&gt;所以什麼是最快的 ELPA? 讓我們來定義一下! ELPA 最能跑? 不對, 這一點都不合邏
輯. ELPA 最快服務你? 或許, 但我不知道!&lt;/p&gt;
&lt;p&gt;在這裡我們定義&amp;quot;最快的 ELPA&amp;quot;為建構插件的速度. 也就是多久以後我們的插件會
被更新在服務器上. 就算更新了我們的插件, 也不用等上一段時間. 你可能會想說
&amp;ldquo;怎麼可能?&amp;rdquo; 還有 &amp;ldquo;怎麼做到的?&amp;rdquo;, 讓我一一解釋!&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;一般的 ELPA, 像是 MELPA, 他們會從 &lt;code&gt;recipes&lt;/code&gt; 資料夾裡取得需要建構的插件目標.
這裡的時間為 O(n), 越多插件則會花越多時間. 通常簡單的解決方法就是直接提升
硬體硬件, 來促使減少建構時間.&lt;/p&gt;
&lt;p&gt;這裡 &lt;a href=&#34;https://jcs-emacs.github.io/jcs-elpa/&#34;&gt;JCS-ELPA&lt;/a&gt; 使用了不同的策略. 這個 ELPA 使用了一個插件 &lt;a href=&#34;https://github.com/10sr/github-elpa&#34;&gt;github-elpa&lt;/a&gt;
來使其建構我們的插件然後上傳到 &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt;. 所以到底為什麼會是最快?
主要有兩個因素:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微軟擁有 GitHub. 技術上來說, 我們的 ELPA 是直接跑在微軟的服務器上&lt;/li&gt;
&lt;li&gt;我們使用 &lt;a href=&#34;https://github.com/features/actions&#34;&gt;GitHub Actions&lt;/a&gt; 建構插件, 定且使用了多個 jobs (如果你不熟悉
GHA, 就想說有很多台電腦在幫你做事即可)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JCS-ELPA 使用這技術來達成很多 worker 幫你同時建構插件. 公式如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;新的建構總時長 = 原本建構總時長 / 工作者
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果工作者為 1, 建構時長則保持不變 (建構時長沒有任何改善).
舉例, 如果&lt;code&gt;原本建構總時長&lt;/code&gt;是 10 分鐘, 開 5 個工作者 則會減少為 2 分鐘.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
